职责链的优点是:

> 请求发送者只需要知道链中的第一个节点, 从而弱化了发送者和一组接收者之间的强联系

职责链的核心思想是, 把一个任务(请求)交给一个接收者去处理, 如果这个接收者处理不了或者处理完了自己能处理的部分, 则他会转交给下一个接收者处理, 直到任务被处理. 有些时候是接收者无法处理, 这种情况是任务在链中传递, 有些时候是接收者能部分处理, 这种情况是将大任务分解成小任务, 再在链中传递.

从这个角度来说, 很多地方都体现了这样的思想. 比如我们一层层的函数调用, 每个函数只处理一部分, 然后根据条件调用其他函数处理, 取得其他函数的返回值再继续处理, 最终许多层函数调用完成了一个复杂的任务. 比如 `if-else` 转循环, 比如 Promise 的展开, 比如 Koa 的中间件, 比如管道, 比如让一个任务/参数在合适的数据结构中传递, 都体现了类似的思想.

考虑到现实情况中很多场景并非是线性的一条链走下去, 而是一个树状结构. 所以也许洋葱模型能够更好地描述这种关系? 不过考虑到有时候任务完成我们也需要得到通知, 或者说得知任务的返回结果. 而返回结果通常有两种方式, 一种是通过 `return` 返回值, 一种是回调, 洋葱模型能够比较好地描述立即返回值的情形, 不过似乎不能完全对应着回调?

如果要类比的话, 就好像坐公交车, 你从后门上了车, 然后把钱递给前面的人, 让他一路传递过去到投币箱, 然后司机又告诉身边的人收到了, 让他们一个个把这个收到消息传递给你, 这样是洋葱模型. 但我们直到现实中肯定不会这么傻屌, 实际情况应该是, 你把钱从一个个人传递到了投币箱, 司机大喊了一声收到了, 你就知道了, 这是回调.

有了这些认知, 我们可以知道, 职责链模式不一定要拘泥于某种形式的代码结构, 而是基于这样一种思想.

有一点需要注意, 如果职责链中的请求传递是由每个节点自己来完成, 换句话说, 每个节点需要知道下一个节点具体是哪个节点, 这样的话, 也是会导致耦合, 让整个职责链不易于修改和扩展, 所以往往我们还需要借助一个第三方来调度, 或者将下一个节点统一抽象成一个 `next()` 之类的东西.

但是职责链模式并不能帮你减少代码, 也不能减少逻辑的固有复杂度, 甚至还带来了性能开销, 它带来的只是让代码更可读, 易扩展, 易维护.